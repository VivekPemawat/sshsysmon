{
  "name": "SshSysMon",
  "tagline": "SSH System Monitoring -- Server monitoring for lazy people.",
  "body": "# Unix System Monitoring Over SSH\r\n\r\nSshSysMon is a system/server monitoring tool that executes all of its operations over SSH without the\r\nneed for installing agents across machines.\r\n\r\nIts goal is to provide simple self-hosted monitoring and alerting for small numbers of lightweight\r\nservers without the traditional overhead of a monitoring system.\r\n\r\nIt monitors things in /proc and with simple command executions to monitor system vitals such as: memory, cpu load, drive space, swap, etc.\r\n\r\n\r\n\r\n## Setup\r\n\r\n### Installation\r\n\r\n#### Via PyPi\r\n\r\n```bash\r\npip install sshsysmon\r\n```\r\n\r\n#### Manually (No Install)\r\n\r\n```bash\r\n# Requires python 2.x and pip:\r\nsudo apt-get install -y python python-pip python-dev\r\n\r\n# Download the latest SshSysMon:\r\nwget -O - https://github.com/zix99/sshsysmon/archive/master.tar.gz | tar xzv\r\n\r\n# Make sure the dependencies are installed:\r\ncd sshsysmon-master/\r\nsudo pip install -r requirements.txt\r\n\r\n# Test it out!\r\n./sshmon summary examples/starter.yml\r\n```\r\n\r\n### Setting up a ssh key pair\r\n\r\n**You only need to do this if you are monitoring a remote server.**\r\n\r\nThe best way to connect to remote servers is with private key created and added to the `authorized_hosts` file on\r\nall systems you are interested in monitoring.  While password authentication is supported, this\r\nis the easiest way to guarantee continued authentication to other hosts.\r\n\r\nOn debian-based linux systems, setting up a key-pair to use with SSH is easy.  I would recommend\r\nyou make a new linux user to only do monitoring on each machine, but it isn't required.\r\n\r\n```bash\r\n# 1. Create a new SSH key if you don't already have one. Follow the prompts, but leave the password blank\r\nssh-keygen\r\n\r\n# 2. Install it on a user on another machine that you want to monitor\r\nssh-copy-id username@remotehost\r\n```\r\n\r\n\r\n### Running\r\n\r\nThe service has two commands, `summary` and `check`.\r\n\r\n#### Summary\r\n\r\n`summary` will print out a human-readable summary of all servers specified in the config. It is a\r\ngreat way to validate your config.\r\n\r\nIt can be executed with:\r\n\r\n    ./sshmon.py summary examples/starter.yml\r\n\r\nIt also can be told to use various templates. See templating section below. Eg, to use the html template:\r\n\r\n    ./sshmon.py -f html summary examples/starter.yml\r\n\r\n#### Check\r\n\r\n`check` is meant to be executed as part of a scheduled job, and will notify all channels in the config\r\nif a condition is unmet.\r\n\r\nIt can be excuted with:\r\n\r\n    ./sshmon.py check <myconfig.yml>\r\n\r\n\r\n### Running Scheduled Job\r\n\r\nThe best way to run the service automatically is with a cron job.\r\n\r\nEdit your cron jobs with\r\n\r\n    crontab -e\r\n\r\nAdd an entry that runs the script every few hours: (or minutes, whatever you like)\r\n\r\n    0 */4 * * * /path/to/sshmon.py check /path/to/config.yml\r\n\r\n\r\n### Configuration\r\n\r\nConfiguration is written in yaml and is a set of servers, with a list of monitors with alarms,\r\nnotification channels and connection details.\r\n\r\nSee the [Examples](/examples) folder for more sample configs.\r\n\r\nAn example simple configuration might look something like this:\r\n\r\n```\r\nmeta: #Meta section (Optional). Used by summary templates\r\n  title: \"My Cluster Summary\"\r\n  author: \"Me\"\r\n\r\nservers:\r\n  \"Name of server\":\r\n    driver: ssh\r\n    config:\r\n      host: myhostname.com\r\n      username: myuser\r\n    channels: # Notification targets\r\n      - type: email\r\n        config:\r\n          toAddr: myemail@gmail.com\r\n          subject: \"Something went wrong on {server}\"\r\n    monitors: # All alerts and inspectors\r\n      - type: memory\r\n        alarms:\r\n          \"Low Swap\": \"swap_free.mb < 50\"\r\n          \"Low Memory\": \"mem_free.mb < 5\"\r\n      - type: disk\r\n        alarms:\r\n          \"Low Disk Space\": \"disk_free.gb < 5\"\r\n        summarize: false # Optional, use if you don't want a monitor to show up in the summary\r\n```\r\n\r\nYou can often use YAML's inheritance to simplify your config for more than 1 server.  Each config section also\r\nhas a corresponding `+` version to add more in addition to something merged in.  eg. `monitors+`.\r\n\r\n\r\nAll servers are iterated through, and queried for given inspector types. The resulting `metrics` are compared to\r\nthe `alarms`, and if any of them are unmet, a notification it sent to all configured `channels`.\r\n\r\n#### Data Format\r\n\r\nAll sizes (that is, number of bytes), is enapsulated by the `ByteSize` class, which has helper methods for both friendly\r\noutput, and size casting in the form of `b`, `kb`, `mb`, etc.  eg, you can write `mem_free.mb > 50`.\r\n\r\nPercentages will always be presented in their 0-100 form.\r\n\r\n---\r\n\r\n## Application\r\n\r\n### Components\r\n\r\nThe applications is built on three components: `Drivers`, `Inspectors`, and `Channels`.\r\n\r\nEach has its corresponding folder with abstract implementation.  They are loaded dynamically with their\r\nname or path provided in the configuration.\r\n\r\n#### Drivers\r\n\r\nDrivers are classes that define how to read information from a server.  By default, there are two drivers:\r\n\r\n##### Local\r\n\r\nThe local driver is only for your local machine. There is no config for this driver.\r\n\r\n##### SSH\r\n\r\nThe SSH driver is for reaching out to remote machines.  There are several config paramters for this driver:\r\n\r\n  * host - The hostname of the machine (IP or Domain)\r\n  * username - The username to connect with\r\n  * password - (Not recommended, use key instead) The ssh user's password\r\n  * key - The path to the private key to use to connect (Default: ~/.ssh/id_rsa)\r\n  * port - The port to connect to the machine on (Default: 22)\r\n  * path - The path which proc is located (Default: /proc)\r\n\r\n--\r\n\r\n#### Channels\r\n\r\nChannels define what can happen if an alert fires.  There a few built-in.\r\n\r\nThere are a few variables passed in that can be used to format part of the commands:\r\n\r\n  * server - The server that the alert triggered on\r\n  * alert - The alert that triggered\r\n  * metric - The metric that triggered the alert\r\n\r\n##### stdout\r\n\r\nWrites tab-separated data to stdout.  Can be appended to file with bash `>>` operator.\r\n\r\nArguments:\r\n\r\n  * timeFormat - Either `ctime` or `epoch`, the format which time is output. Default: `ctime`\r\n  * format - The format string used to write output. Default: `{time}\\t{server}\\t{inspector}\\t{alert}`\r\n\r\n##### command\r\n\r\nExecutes a shell command on the machine in which the script is running.\r\n\r\nArguments:\r\n\r\n  * command - The shell command to execute\r\n\r\n##### email\r\n\r\nSends an email via a SMTP server.\r\n\r\nBy default, it assumes a local SMTP server is setup.  For more complex configs, such as how to use\r\ngmail, see the examples.\r\n\r\nArguments:\r\n\r\n  * toAddr - The address to send the email to\r\n  * fromAddr - The address the email should come from (default: username@hostname)\r\n  * host - The SMTP host (default: localhost)\r\n  * port - The SMTP port (default: 25)\r\n  * subject - Subject line of email (has reasonable default)\r\n  * username - Username to authenticate with smtp server (default: none)\r\n  * password - Password to authenticate with smtp server (default: none)\r\n  * tls - Should use tls (default: false)\r\n  * ssl - Should use ssl (default: false)\r\n\r\n--\r\n\r\n#### Inspectors (Alert Types)\r\n\r\nInspects are parsers that know how to read data from a driver and make sense of it.\r\n\r\n##### Memory (memory)\r\n\r\nThe memory driver returns metrics about the systems memory:\r\n\r\nMetrics: mem_total, mem_free, cached, swap_total, swap_free\r\n\r\n##### Disk Space (disk)\r\n\r\nThe Disk driver returns status of the disk space (in GB)\r\n\r\nConfig:\r\n\r\n  * device - The name of the device (Optional, eg /dev/sda)\r\n  * mount - The mount point of the device (default: /)\r\n\r\nMetrics: size, used, available, percent_full\r\n\r\n##### Load Average (loadavg)\r\n\r\nThe load average inspector returns the system's current 1/5/15 minute [load average](http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages).\r\n\r\nMetrics: load_1m, load_5m, load_15m\r\n\r\n##### Process Monitor (process)\r\n\r\nThis inspector will allow you monitor a process on the given machine.\r\n\r\nIt takes in one **required** config `name`. This will use [wildcard matching](https://docs.python.org/2/library/fnmatch.html) with `*` and `?`.\r\n\r\nMetrics: user, pid, cpu, mem, tty\r\n\r\n##### TCP (tcp)\r\n\r\nThe TCP inspector will try to establish a connection on a given port with the same\r\nremote as the driver.  It's important to note that this does **not** go over SSH, and will\r\nnot verify anything more than that the port is willing to establish a connection.\r\n\r\nConfig:\r\n\r\n  * ports: A list, single port, or CSV of ports to check\r\n\r\nMetrics:\r\n\r\n  * A dictionary of the requested ports, prefixed with `port_`, and true if they are open, otherwise false (eg `port_22`)\r\n  * A special `all` metric which will be true if all ports are open\r\n\r\n##### HTTP (http)\r\n\r\nThe Http connector will attempt to do a GET request on a http/https endpoint, and return the data if able.\r\n\r\nConfig:\r\n\r\n  * path: The path to request on (default '/')\r\n  * port: The port to request at (default 80 for http, 443 for https)\r\n  * https: True/false if https (default: http)\r\n  * json: true/false if it should attempt to parse the response as json (Default: false)\r\n  * match: A regex to match against (default: None)\r\n\r\nMetrics:\r\n\r\n  * success: A true/false whether the request returns a 2xx, and all requirements were met (matches, or parses)\r\n  * match: Whether or not the regex matched. `None` if no match requested\r\n  * json: The parsed json, if requested\r\n  * url: The requested url\r\n\r\n##### Custom Command (exec)\r\n\r\n`exec` runs a custom command and returns `stdout`, `stderr`, and `status` (returncode).\r\n\r\nConfig:\r\n\r\n  * command: The shell command to execute\r\n\r\nMetrics:\r\n\r\n  * stdout: The out string of the command\r\n  * stderr: The err string of the command\r\n  * status: The returncode of the command (0 means normal)\r\n\r\n\r\n\r\n\r\n### Templating\r\n\r\nSshSysMon uses handlebars to template its summary output.  See the [templating](/templates) for more information.\r\n\r\n### Writing Your Own Component\r\n\r\nTo learn how to write a specific type of component, visit its readme in the appropriate subfolder.\r\n\r\nAll components must define `def create(args):` as a well-known method to instantiate the class.  `args` will\r\nbe the configuration `dict` given in the configuration.\r\n\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}